<html>
  <head>
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.15.3/dist/tf.min.js"> </script> 
 
    <!-- Place your code in the script tag below. You can also use an external .js file -->
    <script>
      class CharacterTable {
        /**
         * Constructor of CharacterTable.
         * @param chars A string that contains the characters that can appear
         *   in the input.
         */
        constructor(chars) {
          this.chars = chars;
          this.charIndices = {};
          this.indicesChar = {};
          this.size = this.chars.length;
          for (let i = 0; i < this.size; ++i) {
            const char = this.chars[i];
            if (this.charIndices[char] != null) {
              throw new Error(`Duplicate character '${char}'`);
            }
            this.charIndices[this.chars[i]] = i;
            this.indicesChar[i] = this.chars[i];
          }
        }

        /**
         * Convert a string into a one-hot encoded tensor.
         *
         * @param str The input string.
         * @param numRows Number of rows of the output tensor.
         * @returns The one-hot encoded 2D tensor.
         * @throws If `str` contains any characters outside the `CharacterTable`'s
         *   vocabulary.
         */
        encode(str, numRows) {
          const buf = tf.buffer([numRows, this.size]);
          for (let i = 0; i < str.length; ++i) {
            const char = str[i];
            if (this.charIndices[char] == null) {
              throw new Error(`Unknown character: '${char}'`);
            }
            buf.set(1, i, this.charIndices[char]);
          }
          return buf.toTensor().as2D(numRows, this.size);
        }

        encodeBatch(strings, numRows) {
          const numExamples = strings.length;
          const buf = tf.buffer([numExamples, numRows, this.size]);
          for (let n = 0; n < numExamples; ++n) {
            const str = strings[n];
            for (let i = 0; i < str.length; ++i) {
              const char = str[i];
              if (this.charIndices[char] == null) {
                throw new Error(`Unknown character: '${char}'`);
              }
              buf.set(1, n, i, this.charIndices[char]);
            }
          }
          return buf.toTensor().as3D(numExamples, numRows, this.size);
        }

        /**
         * Convert a 2D tensor into a string with the CharacterTable's vocabulary.
         *
         * @param x Input 2D tensor.
         * @param calcArgmax Whether to perform `argMax` operation on `x` before
         *   indexing into the `CharacterTable`'s vocabulary.
         * @returns The decoded string.
         */
        decode(x, calcArgmax = true) {
          return tf.tidy(() => {
            if (calcArgmax) {
              x = x.argMax(1);
            }
            const xData = x.dataSync();  // TODO(cais): Performance implication?
            let output = '';
            for (const index of Array.from(xData)) {
              output += this.indicesChar[index];
            }
            return output;
          });
        }
      }

      /**
       * Generate examples.
       *
       * Each example consists of a question, e.g., '123+456' and and an
       * answer, e.g., '579'.
       *
       * @param digits Maximum number of digits of each operand of the
       * @param numExamples Number of examples to generate.
       * @param invert Whether to invert the strings in the question.
       * @returns The generated examples.
       */
      function generateData(digits, numExamples, invert) {
        const digitArray = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const arraySize = digitArray.length;

        const output = [];
        const maxLen = digits + 1 + digits;

        const f = () => {
          let str = '';
          while (str.length < digits) {
            const index = Math.floor(Math.random() * arraySize);
            str += digitArray[index];
          }
          return Number.parseInt(str);
        };

        const seen = new Set();
        while (output.length < numExamples) {
          const a = f();
          const b = f();
          const sorted = b > a ? [a, b] : [b, a];
          const key = sorted[0] + '`' + sorted[1];
          if (seen.has(key)) {
            continue;
          }
          seen.add(key);

          // Pad the data with spaces such that it is always maxLen.
          const q = `${a}+${b}`;
          const query = q + ' '.repeat(maxLen - q.length);
          let ans = (a + b).toString();
          // Answer can be of maximum size `digits + 1`.
          ans += ' '.repeat(digits + 1 - ans.length);

          if (invert) {
            throw new Error('invert is not implemented yet');
          }
          output.push([query, ans]);
        }
        return output;
      }

      function convertDataToTensors(data, charTable, digits) {
        const maxLen = digits + 1 + digits;
        const questions = data.map(datum => datum[0]);
        const answers = data.map(datum => datum[1]);
        return [
          charTable.encodeBatch(questions, maxLen),
          charTable.encodeBatch(answers, digits + 1),
        ];
      }
 
      const chars = '0123456789+ ';
      charTable = new CharacterTable(chars);
      [trainXs, trainYs] = convertDataToTensors(["4", "9", "16", "25"], charTable, 10);
      
      const MODEL_URL = '/model/tensorflowjs_model.pb'
      const WEIGHTS_URL = '/model/weights_manifest.json'
      async function fun(){
          console.log("111");
          console.time('Loading of model');
          document.write(5+2);
          const model = await tf.loadGraphModel(MODEL_URL, WEIGHTS_URL);
          document.write(0-2);
          console.log("222");
          console.timeEnd('Loading of model');
          model.predict(trainXs).print();
      }
      fun()
    </script> 
  </head>
 
  <body>
  </body>
</html>
